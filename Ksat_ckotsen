# -*- coding: utf-8 -*-
"""Copy of Theory Proj 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n_-cSS6D-NgvtADY8HCCbdCtBo0ZlGkm
"""
import random
import time
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit

# Modified functions from DumbSAT.py (incremental search)
def build_wff(nvars, nclauses, nliterals):
    wff = []
    for _ in range(nclauses):
        clause = []
        for _ in range(nliterals):
            var = random.randint(1, nvars)
            if random.choice([True, False]):
                clause.append(var)
            else:
                clause.append(-var)
        wff.append(clause)
    return wff

def unit_propagate(wff, assignment):
    unit_clauses = [clause for clause in wff if len(clause) == 1]
    while unit_clauses:
        unit = unit_clauses[0][0]
        assignment[abs(unit)] = True if unit > 0 else False
        new_wff = []
        for clause in wff:
            if unit in clause:
                continue
            new_clause = [lit for lit in clause if lit != -unit]
            if not new_clause:
                return False
            new_wff.append(new_clause)
        wff = new_wff
        unit_clauses = [clause for clause in wff if len(clause) == 1]
    return wff

def dpll(wff, assignment, nvars):
    wff = unit_propagate(wff, assignment)
    if wff is False:
        return False
    if not wff:
        return True
    for var in range(1, nvars + 1):
        if var not in assignment:
            assignment[var] = True
            if dpll(wff + [[var]], assignment, nvars):
                return True
            assignment[var] = False
            if dpll(wff + [[-var]], assignment, nvars):
                return True
            del assignment[var]
            return False

def check(wff, nvars):
    assignment = {}
    return dpll(wff, assignment, nvars), assignment

def test_wff(nvars, nclauses, nliterals):
    wff = build_wff(nvars, nclauses, nliterals)
    start = time.time()
    satisfiable, assignment = check(wff, nvars)
    elapsed = time.time() - start
    return satisfiable, assignment, elapsed

def run_cases():
    nvars_list = [50, 100, 150]     # Number of variables
    nclauses_list = [100, 200, 300] # Number of clauses
    nliterals_list = [2, 3, 4]                # Number of literals per clause


    sizes = []  # To store problem sizes (nvars * nclauses * nliterals)
    times = []  # To store time taken for each configuration

    for nvars in nvars_list:
        for nclauses in nclauses_list:
            for nliterals in nliterals_list:
                satisfiable, assignment, elapsed = test_wff(nvars, nclauses, nliterals)

                # Record problem size and time
                problem_size = nvars * nclauses * nliterals
                sizes.append(problem_size)
                times.append(elapsed)
                print(f"Problem Size: {problem_size}, Time: {elapsed:.4f} sec")

    return sizes, times

def plot_times(sizes, times):
    # Scatter plot of problem sizes vs. time
    plt.figure(figsize=(10, 6))
    plt.scatter(sizes, times, color='blue', label="Time")
    plt.xlabel('Problem Size (Variables * Clauses * Literals)')
    plt.ylabel('Time (seconds)')
    plt.title('Time Complexity vs. Problem Size for SAT Solver')
    plt.grid(True)

    # Fit a curve to approximate the worst-case time complexity
    def bounding_curve(x, a, b, c):
        return a * np.exp(b * x) + c  # Example of an exponential bounding curve

    popt, _ = curve_fit(bounding_curve, sizes, times)

    # Generate points for the fitted curve
    x_fit = np.linspace(min(sizes), max(sizes), 100)
    y_fit = bounding_curve(x_fit, *popt)

    plt.plot(x_fit, y_fit, 'r--', label=f"Bounding Curve: {popt[0]:.3e} * exp({popt[1]:.3e} * x) + {popt[2]:.3e}")
    plt.legend()

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    # Run cases and capture the sizes and times
    sizes, times = run_cases()

    # Plot the results with a bounding curve
    plot_times(sizes, times)
